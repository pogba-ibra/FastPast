const express = require("express");
const cors = require("cors");
const { spawn } = require("child_process");
const path = require("path");
const multer = require("multer");
const ffmpeg = require("ffmpeg-static");
const winston = require("winston");
const DailyRotateFile = require("winston-daily-rotate-file");
const Queue = require('better-queue');
const { Server } = require("socket.io");
const http = require('http');
const { v4: uuidv4 } = require('uuid');
const fs = require('fs');
const mongoose = require('mongoose');
const User = require('./models/User');
const Session = require('./models/Session');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { requireAuth, refreshSession } = require('./middleware/auth.middleware');
const { checkDownloadLimit } = require('./middleware/membership.middleware');
const emailService = require('./utils/email.service');

// Storage mode flag
let USE_MONGODB = false;
let USERS_DATA = [];
let SESSIONS_DATA = [];

// File paths for JSON storage
const USERS_FILE = path.join(__dirname, 'json-data', 'users.json');
const SESSIONS_FILE = path.join(__dirname, 'json-data', 'sessions.json');

// JSON storage helper functions
function initJsonStorage() {
  if (!fs.existsSync(path.join(__dirname, 'json-data'))) {
    fs.mkdirSync(path.join(__dirname, 'json-data'));
  }
  if (!fs.existsSync(USERS_FILE)) {
    fs.writeFileSync(USERS_FILE, JSON.stringify([]));
  }
  if (!fs.existsSync(SESSIONS_FILE)) {
    fs.writeFileSync(SESSIONS_FILE, JSON.stringify([]));
  }
  USERS_DATA = JSON.parse(fs.readFileSync(USERS_FILE, 'utf8'));
  SESSIONS_DATA = JSON.parse(fs.readFileSync(SESSIONS_FILE, 'utf8'));
  console.log('üìÅ Using JSON file storage for authentication');
}

function saveUsers() {
  if (!USE_MONGODB) {
    fs.writeFileSync(USERS_FILE, JSON.stringify(USERS_DATA, null, 2));
  }
}

function saveSessions() {
  if (!USE_MONGODB) {
    fs.writeFileSync(SESSIONS_FILE, JSON.stringify(SESSIONS_DATA, null, 2));
  }
}

// Try to connect to MongoDB with timeout
mongoose.connect('mongodb://localhost:27017/video-downloader', {
  serverSelectionTimeoutMS: 3000,
  connectTimeoutMS: 3000
})
  .then(() => {
    USE_MONGODB = true;
    console.log('‚úÖ MongoDB connected - Using MongoDB for authentication');
  })
  .catch(err => {
    console.log('‚ö†Ô∏è  MongoDB not available:', err.message);
    console.log('üìÅ Falling back to JSON file storage');
    USE_MONGODB = false;
    initJsonStorage();
    // Seed test users if JSON storage is empty
    if (USERS_DATA.length === 0) {
      seedJsonUsers();
    }
  });

// Seed test users for JSON storage
async function seedJsonUsers() {
  console.log('üå± Seeding JSON test users...\n');
  const testUsers = [
    { username: 'free_user', email: 'free@test.com', password: 'Test1234!', membershipType: 'free' },
    { username: 'monthly_user', email: 'monthly@test.com', password: 'Test1234!', membershipType: 'monthly' },
    { username: 'lifetime_user', email: 'lifetime@test.com', password: 'Test1234!', membershipType: 'lifetime' }
  ];

  for (const userData of testUsers) {
    const hashedPassword = await bcrypt.hash(userData.password, 10);
    const subscriptionEndDate = userData.membershipType === 'monthly'
      ? new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
      : null;

    USERS_DATA.push({
      id: crypto.randomBytes(16).toString('hex'),
      username: userData.username,
      email: userData.email,
      password: hashedPassword,
      membershipType: userData.membershipType,
      subscriptionStatus: 'active',
      subscriptionEndDate,
      isEmailVerified: true,
      createdAt: new Date(),
      lastLogin: null,
      dailyDownloadCount: 0,
      lastDownloadReset: new Date()
    });
    console.log(`‚úÖ Created: ${userData.username} (${userData.membershipType})`);
  }
  saveUsers();
  console.log('\nüéâ Test users created! Login: free@test.com / Test1234!\n');
}


// Configure Winston logger
const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: "video-downloader" },
  transports: [
    // Write all logs with importance level of `error` or less to `error.log`
    new DailyRotateFile({
      filename: "logs/error-%DATE%.log",
      datePattern: "YYYY-MM-DD",
      level: "error",
      maxSize: "20m",
      maxFiles: "14d",
    }),
    // Write all logs with importance level of `info` or less to `combined.log`
    new DailyRotateFile({
      filename: "logs/combined-%DATE%.log",
      datePattern: "YYYY-MM-DD",
      maxSize: "20m",
      maxFiles: "14d",
    }),
  ],
});

// If we're not in production then log to the console with a simple format
if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      ),
    })
  );
}

// Function to parse MM:SS to seconds
function parseTime(timeStr) {
  const [min, sec] = timeStr.split(":").map(Number);
  return min * 60 + sec;
}

function encodeRFC5987Value(value) {
  return encodeURIComponent(value)
    .replace(/['()]/g, (char) => `%${char.charCodeAt(0).toString(16).toUpperCase()}`)
    .replace(/\*/g, "%2A");
}

function getContentDisposition(filename) {
  const fallback = filename.replace(/[^\x20-\x7E]/g, "_").replace(/"/g, "'");
  return `attachment; filename="${fallback}"; filename*=UTF-8''${encodeRFC5987Value(filename)}`;
}

function getFormatScore(format) {
  let score = 0;
  if (format.ext === "mp4") {
    score += 500000;
  }
  if (format.vcodec && /avc|h264/i.test(format.vcodec)) {
    score += 20000;
  }
  if (typeof format.tbr === "number") {
    score += format.tbr;
  }
  if (typeof format.filesize === "number") {
    score += format.filesize / 1000000;
  }
  return score;
}

function buildQualityLabel(height) {
  return `${height}p (${height >= 1080 ? "High Quality" : height >= 720 ? "HD Quality" : "Standard Quality"})`;
}

function buildFallbackQuality(height) {
  return {
    value: `bestvideo[height<=${height}]+bestaudio/best[height<=${height}]/best`,
    text: buildQualityLabel(height),
    height,
    hasAudio: false,
    ext: "mp4",
  };
}

function selectVideoQualities(formats) {
  const heightMap = new Map();
  formats.forEach((format) => {
    if (!format || format.vcodec === "none" || !format.height) {
      return;
    }
    if (format.height < 144 || format.height > 4320) {
      return;
    }
    const entry = heightMap.get(format.height) || { combined: null, videoOnly: null };
    const scored = { format, score: getFormatScore(format) };
    if (format.acodec && format.acodec !== "none") {
      if (!entry.combined || scored.score > entry.combined.score) {
        entry.combined = scored;
      }
    } else {
      if (!entry.videoOnly || scored.score > entry.videoOnly.score) {
        entry.videoOnly = scored;
      }
    }
    heightMap.set(format.height, entry);
  });

  const selectedHeights = Array.from(heightMap.keys())
    .sort((a, b) => a - b)
    .slice(-6);

  return selectedHeights
    .map((height) => {
      const entry = heightMap.get(height);
      if (!entry) {
        return null;
      }
      if (entry.combined) {
        return {
          value: entry.combined.format.format_id,
          text: buildQualityLabel(height),
          height,
          hasAudio: true,
          ext: entry.combined.format.ext || "mp4",
        };
      }
      if (entry.videoOnly) {
        return {
          value: `${entry.videoOnly.format.format_id}+bestaudio/best`,
          text: buildQualityLabel(height),
          height,
          hasAudio: false,
          ext: entry.videoOnly.format.ext || "mp4",
        };
      }
      return null;
    })
    .filter(Boolean);
}

const vkHostAliases = new Set([
  "vkvideo.ru",
  "www.vkvideo.ru",
  "vk.ru",
  "www.vk.ru",
  "vkontakte.ru",
  "www.vkontakte.ru",
]);

function normalizeVkUrl(url) {
  if (!url || typeof url !== "string") {
    return url;
  }

  const trimmed = url.trim();
  if (!trimmed) {
    return trimmed;
  }

  try {
    const parsedUrl = new URL(trimmed);
    if (vkHostAliases.has(parsedUrl.hostname.toLowerCase())) {
      parsedUrl.hostname = "vk.com";
      return parsedUrl.toString();
    }
    return trimmed;
  } catch (error) {
    return trimmed;
  }
}

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
});
const port = 3002;

const downloadDir = path.join(__dirname, 'downloads');
if (!fs.existsSync(downloadDir)) {
  fs.mkdirSync(downloadDir);
}

// Queue Processing Logic
const downloadQueue = new Queue(function (task, cb) {
  const { url, jobId, format, qualityLabel } = task;
  const startTime = Date.now();

  logger.info(`Starting batch download task`, { jobId, url });
  io.emit('job_start', { jobId, url });

  // Default args - similar to standard download but writing to file
  const outputTemplate = path.join(downloadDir, `${jobId}_%(title)s.%(ext)s`);

  let args = [
    "-o", outputTemplate,
    "--no-check-certificate",
    "--ffmpeg-location", ffmpeg,
    "--progress", // Ensure progress is printed
    "--newline", // Easier to parse
  ];

  if (url.includes("youtube.com") || url.includes("youtu.be")) {
    args.push("--impersonate", "Chrome-131");
    args.push("--extractor-args", "youtube:player_client=default,ios");
  }
  if (url.includes("vimeo.com")) {
    args.push("--extractor-args", "vimeo:player_url=https://player.vimeo.com");
    args.push("--cookies-from-browser", "chrome");
  }

  if (format) {
    args.push("-f", format);
  } else {
    args.push("-f", "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best");
  }

  args.push(url);

  const ytDlp = spawn("py", ["-m", "yt_dlp", ...args]);

  let stderr = "";

  ytDlp.stdout.on("data", (data) => {
    const line = data.toString();
    // Simple progress parsing: [download]  45.0% of 10.00MiB at 2.00MiB/s
    const match = line.match(/\[download\]\s+(\d+\.?\d*)%/);
    if (match) {
      const percent = parseFloat(match[1]);
      io.emit('job_progress', { jobId, percent, url });
    }
  });

  ytDlp.stderr.on("data", (data) => {
    stderr += data.toString();
  });

  ytDlp.on("close", (code) => {
    if (code === 0) {
      io.emit('job_complete', { jobId, url });
      logger.info(`Batch download completed`, { jobId, duration: Date.now() - startTime });
      cb(null, { status: 'completed' });
    } else {
      io.emit('job_error', { jobId, error: "Process exited with code " + code, url });
      logger.error(`Batch download process failed`, { jobId, code, stderr });
      cb(new Error(`Process exited with code ${code}`));
    }
  });

  ytDlp.on("error", (err) => {
    io.emit('job_error', { jobId, error: err.message, url });
    logger.error(`Batch download error`, { jobId, error: err.message });
    cb(err);
  });

}, { concurrent: 2 });




const downloadStats = downloadQueue.getStats();

app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, "Web")));
app.use("/style", express.static(path.join(__dirname, "style")));
app.use("/js", express.static(path.join(__dirname, "js")));

app.post('/auth/register', async (req, res) => {
  try {
    const { username, email, password, membershipType } = req.body;

    // Validate membership type
    const validMemberships = ['free', 'monthly', 'semi-yearly', 'yearly', 'lifetime'];
    if (membershipType && !validMemberships.includes(membershipType)) {
      return res.status(400).json({ error: 'Invalid membership type' });
    }

    // Check if user exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ error: 'Email already in use' });
    }

    // Hash password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    // Generate email verification token
    const verificationToken = crypto.randomBytes(32).toString('hex');
    const verificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    // Calculate subscription end date for paid memberships
    let subscriptionEndDate = null;
    if (membershipType === 'monthly') {
      subscriptionEndDate = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
    } else if (membershipType === 'semi-yearly') {
      subscriptionEndDate = new Date(Date.now() + 180 * 24 * 60 * 60 * 1000);
    } else if (membershipType === 'yearly') {
      subscriptionEndDate = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000);
    }

    // Create user
    const newUser = await User.create({
      username,
      email,
      password: hashedPassword,
      membershipType: membershipType || 'free',
      subscriptionEndDate,
      emailVerificationToken: verificationToken,
      emailVerificationExpires: verificationExpires
    });

    // Send verification email (console log for now)
    emailService.sendVerificationEmail(newUser, verificationToken);

    // Create initial session
    const sessionToken = crypto.randomBytes(64).toString('hex');
    const sessionExpires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

    await Session.create({
      userId: newUser._id,
      sessionToken,
      expiresAt: sessionExpires,
      ipAddress: req.ip || req.connection.remoteAddress,
      userAgent: req.headers['user-agent']
    });

    // Remove password from output
    const userOutput = newUser.toObject();
    delete userOutput.password;
    delete userOutput.emailVerificationToken;

    res.status(201).json({
      status: 'success',
      message: 'Registration successful! Please check your email to verify your account.',
      data: {
        user: userOutput,
        sessionToken,
        expiresAt: sessionExpires
      }
    });
  } catch (err) {
    logger.error('Registration error', { error: err.message });
    if (err.name === 'ValidationError') {
      const messages = Object.values(err.errors).map(val => val.message);
      return res.status(400).json({ error: messages.join('. ') });
    }
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

// Login endpoint
app.post('/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    // Find user and include password field
    const user = await User.findOne({ email }).select('+password');

    if (!user) {
      return res.status(401).json({ error: 'Invalid email or password' });
    }

    // Compare passwords
    const isPasswordValid = await user.comparePassword(password);

    if (!isPasswordValid) {
      return res.status(401).json({ error: 'Invalid email or password' });
    }

    // Update last login
    user.lastLogin = new Date();
    await user.save();

    // Create new session
    const sessionToken = crypto.randomBytes(64).toString('hex');
    const sessionExpires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

    await Session.create({
      userId: user._id,
      sessionToken,
      expiresAt: sessionExpires,
      ipAddress: req.ip || req.connection.remoteAddress,
      userAgent: req.headers['user-agent']
    });

    // Remove sensitive data
    const userOutput = user.toObject();
    delete userOutput.password;

    logger.info('User logged in', { userId: user._id, email: user.email });

    res.json({
      status: 'success',
      message: 'Login successful',
      data: {
        user: userOutput,
        sessionToken,
        expiresAt: sessionExpires
      }
    });
  } catch (err) {
    logger.error('Login error', { error: err.message });
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

// Logout endpoint
app.post('/auth/logout', requireAuth, async (req, res) => {
  try {
    // Delete the session
    await Session.deleteOne({ _id: req.session._id });

    logger.info('User logged out', { userId: req.user._id });

    res.json({
      status: 'success',
      message: 'Logout successful'
    });
  } catch (err) {
    logger.error('Logout error', { error: err.message });
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

// Check session endpoint
app.get('/auth/session', requireAuth, refreshSession, async (req, res) => {
  try {
    // Remove sensitive data
    const userOutput = req.user.toObject();
    delete userOutput.password;

    res.json({
      status: 'success',
      data: {
        user: userOutput,
        session: {
          expiresAt: req.session.expiresAt
        }
      }
    });
  } catch (err) {
    logger.error('Session check error', { error: err.message });
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

// Email verification endpoint
app.get('/auth/verify-email/:token', async (req, res) => {
  try {
    const { token } = req.params;

    // Find user with this token
    const user = await User.findOne({
      emailVerificationToken: token,
      emailVerificationExpires: { $gt: new Date() }
    }).select('+emailVerificationToken +emailVerificationExpires');

    if (!user) {
      return res.status(400).send(`
        <html>
          <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
            <h1>‚ùå Verification Failed</h1>
            <p>Invalid or expired verification link.</p>
            <a href="/login.html">Go to Login</a>
          </body>
        </html>
      `);
    }

    // Mark email as verified
    user.isEmailVerified = true;
    user.emailVerificationToken = undefined;
    user.emailVerificationExpires = undefined;
    await user.save();

    // Send welcome email
    emailService.sendWelcomeEmail(user);

    logger.info('Email verified', { userId: user._id, email: user.email });

    res.send(`
      <html>
        <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
          <h1>‚úÖ Email Verified!</h1>
          <p>Your email has been successfully verified.</p>
          <p>You can now login to your account.</p>
          <a href="/login.html" style="display: inline-block; margin-top: 20px; padding: 10px 20px; background-color: #457b9d; color: white; text-decoration: none; border-radius: 5px;">Go to Login</a>
        </body>
      </html>
    `);
  } catch (err) {
    logger.error('Email verification error', { error: err.message });
    res.status(500).send('Verification error');
  }
});

// Favicon route to prevent 404 errors
app.get("/favicon.ico", (req, res) => {
  res.sendFile(path.join(__dirname, "Web", "Images", "logo.png"));
});

// Serve theme toggle script from root
app.get("/theme-toggle-final.js", (req, res) => {
  res.sendFile(path.join(__dirname, "theme-toggle-final.js"));
});

app.get("/oembed", async (req, res) => {
  const url = req.query.url;
  if (!url) {
    return res.status(400).json({ error: "URL required" });
  }
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error("Failed to fetch");
    }
    const data = await response.json();
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get("/proxy-image", async (req, res) => {
  const url = req.query.url;
  if (!url) {
    return res.status(400).send("URL required");
  }
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error("Failed to fetch image");
    }
    const buffer = await response.arrayBuffer();
    res.set(
      "Content-Type",
      response.headers.get("content-type") || "image/jpeg"
    );
    res.send(Buffer.from(buffer));
  } catch (error) {
    res.status(500).send("Error fetching image");
  }
});


function streamProcessToResponse(res, childProcess, options) {
  const { filename, contentType, timeoutMs = 300000, onSuccess, onFailure } = options;
  let stderr = "";
  let headersSent = false;
  let responseClosed = false;

  // Handle client disconnect or pipe errors
  const errorHandler = (err) => {
    // EPIPE or ECONNRESET expected when client disconnects
    if (err.code === "EPIPE" || err.code === "ECONNRESET") {
      // Do not throw, just cleanup
    } else {
      console.error("Response stream error:", err);
    }
    responseClosed = true;
    cleanup();
    if (!childProcess.killed) {
      childProcess.kill("SIGKILL");
    }
  };

  res.on("error", errorHandler);
  if (res.socket) {
    res.socket.on("error", errorHandler);
  }

  const sendHeaders = () => {
    if (headersSent) {
      return;
    }
    headersSent = true;
    res.setHeader("Content-Disposition", getContentDisposition(filename));
    res.setHeader("Content-Type", contentType);
  };
  const timeout = setTimeout(() => {
    responseClosed = true;
    childProcess.kill("SIGKILL");
    if (!headersSent) {
      res.status(500).json({
        error:
          "Download timed out. The video might be too large or there may be a connection issue.",
      });
    } else {
      res.destroy(new Error("Download timed out"));
    }
    if (onFailure) {
      onFailure("timeout", stderr);
    }
  }, timeoutMs);
  const cleanup = () => {
    clearTimeout(timeout);
  };
  const handleBackpressure = (chunk) => {
    if (responseClosed) {
      return;
    }
    if (!headersSent) {
      sendHeaders();
    }
    let canContinue = false;
    try {
      canContinue = res.write(chunk);
    } catch (writeErr) {
      errorHandler(writeErr);
      return;
    }
    if (!canContinue) {
      childProcess.stdout.pause();
      res.once("drain", () => {
        if (!responseClosed) {
          childProcess.stdout.resume();
        }
      });
    }
  };
  const failResponse = (message) => {
    if (responseClosed) {
      return;
    }
    responseClosed = true;
    if (!headersSent) {
      res.status(500).json({
        error: "Failed to download video.",
        details: message || stderr || "Download process failed.",
      });
    } else {
      res.destroy(new Error(message || "Download failed"));
    }
    if (onFailure) {
      onFailure(message || "process_failed", stderr);
    }
  };
  childProcess.stderr.on("data", (data) => {
    stderr += data.toString();
  });
  childProcess.stdout.on("data", (chunk) => {
    handleBackpressure(chunk);
  });
  childProcess.on("close", (code) => {
    cleanup();
    if (responseClosed) {
      return;
    }
    if (code === 0) {
      responseClosed = true;
      if (!headersSent) {
        sendHeaders();
      }
      res.end();
      if (onSuccess) {
        onSuccess();
      }
    } else {
      failResponse(`Process exited with code ${code}`);
    }
  });
  childProcess.on("error", (error) => {
    cleanup();
    failResponse(error.message);
  });
  res.on("close", () => {
    if (responseClosed) {
      return;
    }
    responseClosed = true;
    cleanup();
    if (!childProcess.killed) {
      childProcess.kill("SIGKILL");
    }
    if (onFailure) {
      onFailure("client_closed", stderr);
    }
  });
}

async function getVimeoVideoData(url) {
  try {
    // Ensure URL has protocol
    let cleanUrl = url;
    if (!cleanUrl.startsWith("http")) {
      cleanUrl = "https://" + cleanUrl;
    }

    const vimeoMatch = cleanUrl.match(/vimeo\.com\/(\d+)/);
    if (!vimeoMatch) {
      throw new Error("Invalid Vimeo URL format");
    }

    const videoId = vimeoMatch[1];
    const pageResponse = await fetch(cleanUrl.split("?")[0], {
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate, br",
        Referer: "https://vimeo.com/",
      },
    });

    if (!pageResponse.ok) {
      throw new Error(`Page request failed: ${pageResponse.status}`);
    }

    const pageHtml = await pageResponse.text();
    let videoUrl = null;
    let title = `Vimeo video ${videoId}`;
    let duration = 0;
    let thumbnail = null;

    // Try to extract from window.config object first
    const configMatch = pageHtml.match(/window\.config\s*=\s*(\{[\s\S]*?\});/);
    if (configMatch) {
      try {
        const config = JSON.parse(configMatch[1]);
        videoUrl =
          config.request?.files?.progressive?.[0]?.url ||
          config.request?.files?.hls?.cdns?.[Object.keys(config.request.files.hls.cdns || {})[0]]?.url ||
          null;
        title = config.video?.title || title;
        duration = config.video?.duration || 0;
        thumbnail =
          config.video?.thumbs?.base ||
          config.video?.thumbnails?.[0]?.url ||
          null;
      } catch (e) {
        logger.warn("Failed to parse window.config", { error: e.message });
      }
    }

    // Try extracting from embedded JSON-LD if not found
    if (!videoUrl) {
      const jsonLdMatch = pageHtml.match(
        /<script type="application\/ld\+json">([\s\S]*?)<\/script>/
      );
      if (jsonLdMatch) {
        try {
          const jsonLd = JSON.parse(jsonLdMatch[1]);
          if (jsonLd.contentUrl) {
            videoUrl = jsonLd.contentUrl;
          }
          if (jsonLd.name) {
            title = jsonLd.name;
          }
          if (jsonLd.duration) {
            const match = jsonLd.duration.match(/PT(\d+)M(\d+)S/);
            if (match) {
              duration = parseInt(match[1]) * 60 + parseInt(match[2]);
            }
          }
          if (jsonLd.thumbnailUrl) {
            thumbnail = jsonLd.thumbnailUrl;
          }
        } catch (e) {
          logger.warn("Failed to parse JSON-LD", { error: e.message });
        }
      }
    }

    // Try extracting direct MP4 URL from page
    if (!videoUrl) {
      const mp4Match = pageHtml.match(
        /"(https:\/\/[^"]*?\.mp4[^"]*?)"/
      );
      if (mp4Match) {
        videoUrl = mp4Match[1];
      }
    }

    // Extract meta tags for title and thumbnail if not found
    if (!title || title.startsWith("Vimeo video")) {
      const titleMatch = pageHtml.match(
        /<meta property="og:title" content="([^"]+)"/
      );
      if (titleMatch) {
        title = titleMatch[1];
      }
    }

    if (!thumbnail) {
      const thumbMatch = pageHtml.match(
        /<meta property="og:image" content="([^"]+)"/
      );
      if (thumbMatch) {
        thumbnail = thumbMatch[1];
      }
    }

    if (!videoUrl) {
      throw new Error("No video URL found in page");
    }

    logger.info("Vimeo video data extracted successfully", {
      videoId: videoId,
      hasThumbnail: !!thumbnail,
      title: title,
    });

    return {
      videoUrl: videoUrl,
      thumbnail: thumbnail,
      title: title,
      duration: duration,
      height: 720,
    };
  } catch (error) {
    logger.error("Vimeo video data extraction failed", {
      url: url,
      error: error.message,
    });
    return null;
  }
}

async function getThreadsVideoData(url) {
  try {
    const postMatch = url.match(/\/@([^\/]+)\/post\/([^\/\?&]+)/);
    if (!postMatch) {
      throw new Error("Invalid Threads URL format");
    }

    const username = postMatch[1];

    const pageResponse = await fetch(url.split("?")[0], {
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate, br",
        "Sec-Fetch-Dest": "document",
        "Sec-Fetch-Mode": "navigate",
        "Sec-Fetch-Site": "none",
        "Cache-Control": "max-age=0",
        Pragma: "no-cache",
      },
    });

    if (!pageResponse.ok) {
      throw new Error(`Page request failed: ${pageResponse.status}`);
    }

    const pageHtml = await pageResponse.text();
    const normalizedHtml = pageHtml.replace(/\\\//g, "/");
    const combinedHtml = `${pageHtml}\n${normalizedHtml}`;

    const normalizeUrlString = (value) => {
      if (!value || typeof value !== "string") {
        return value;
      }
      return value
        .replace(/\\u0026/g, "&")
        .replace(/&amp;/gi, "&")
        .replace(/\\\//g, "/")
        .trim();
    };

    const safeParseJson = (value) => {
      try {
        return JSON.parse(value);
      } catch (err) {
        logger.warn("Failed to parse Threads structured data", {
          error: err.message,
        });
        return null;
      }
    };

    const findVideoNode = (payload) => {
      const stack = [payload];
      while (stack.length) {
        const current = stack.pop();
        if (!current || typeof current !== "object") {
          continue;
        }
        if (
          Array.isArray(current.video_versions) &&
          current.video_versions.length > 0
        ) {
          return current;
        }
        const values = Array.isArray(current)
          ? current
          : Object.values(current);
        for (const value of values) {
          if (value && typeof value === "object") {
            stack.push(value);
          }
        }
      }
      return null;
    };

    let structuredData = null;
    const nextDataMatch = pageHtml.match(
      /<script id="__NEXT_DATA__"[^>]*>([\s\S]*?)<\/script>/i
    );
    if (nextDataMatch) {
      structuredData = safeParseJson(nextDataMatch[1]);
    }

    if (!structuredData) {
      const additionalDataMatch = pageHtml.match(
        /window\.__additionalDataLoaded\([^,]+,(\{[\s\S]*?\})\);/
      );
      if (additionalDataMatch) {
        structuredData = safeParseJson(additionalDataMatch[1]);
      }
    }

    let videoUrl = null;
    let thumbnail = null;
    let title = `Threads video by @${username}`;
    let duration = 0;

    if (structuredData) {
      const videoNode = findVideoNode(structuredData);
      if (videoNode) {
        const versions = [...(videoNode.video_versions || [])].sort((a, b) => {
          const heightA = a.height || a.width || 0;
          const heightB = b.height || b.width || 0;
          return heightB - heightA;
        });
        if (versions.length > 0) {
          videoUrl = versions[0].url || versions[0].src || null;
        }
        thumbnail =
          videoNode.thumbnail_src ||
          videoNode.thumbnail_url ||
          videoNode.thumbnail ||
          videoNode.cover_media?.cropped_thumbnail?.url ||
          videoNode.image_versions2?.candidates?.[0]?.url ||
          videoNode.display_url ||
          thumbnail;
        if (videoNode.caption?.text) {
          title = videoNode.caption.text.trim();
        } else if (videoNode.user?.username) {
          title = `Threads video by @${videoNode.user.username}`;
        }
        duration =
          videoNode.video_duration ||
          videoNode.duration ||
          videoNode.duration_seconds ||
          videoNode.original_duration ||
          duration;
      }
    }

    if (!videoUrl) {
      const videoUrlMatch = combinedHtml.match(
        /https:\/\/[^"\s]*?\.(?:mp4|webm|mov)[^"\s]*/i
      );
      if (videoUrlMatch && videoUrlMatch.length > 0) {
        videoUrl = videoUrlMatch[0];
      }
    }

    if (!thumbnail) {
      const ogImageMatch = combinedHtml.match(
        /property="og:image"\s+content="([^"]+)"/i
      );
      if (ogImageMatch) {
        thumbnail = ogImageMatch[1];
      }
    }

    if (!title || title.length === 0) {
      const ogTitleMatch = combinedHtml.match(
        /property="og:title"\s+content="([^"]+)"/i
      );
      if (ogTitleMatch) {
        title = ogTitleMatch[1];
      }
    }

    if (!videoUrl) {
      throw new Error("No video URL found in Threads page");
    }

    videoUrl = normalizeUrlString(videoUrl);
    thumbnail = normalizeUrlString(thumbnail);

    logger.info("Threads video data extracted successfully", {
      videoUrl: videoUrl.substring(0, 100) + "...",
      hasThumbnail: !!thumbnail,
      title: title,
    });

    return {
      videoUrl: videoUrl,
      thumbnail: thumbnail,
      title: title,
      duration: Math.round(duration) || 0,
      height: 720,
    };
  } catch (error) {
    logger.error("Threads video data extraction failed", {
      url: url,
      error: error.message,
    });
    return null;
  }
}

app.post("/batch-download", async (req, res) => {
  const { urls, playlistUrl, format } = req.body;

  if (!urls && !playlistUrl) {
    return res.status(400).json({ error: "Provide 'urls' array or 'playlistUrl'" });
  }

  let targets = [];

  if (urls && Array.isArray(urls)) {
    targets = urls;
  } else if (playlistUrl) {
    // TODO: Implement actual playlist extraction if needed, for now assuming client sends flattened list or just single URL
    // Or we could run yt-dlp -J --flat-playlist to get URLs.
    // For simplicity in this step, let's treat playlistUrl as a single target or implement extraction later.
    targets.push(playlistUrl);
  }

  const tasks = targets.map(url => {
    const jobId = uuidv4();
    downloadQueue.push({
      jobId,
      url,
      format: format || "best",
      qualityLabel: "Batch Auto"
    });
    return { jobId, url };
  });

  res.json({ message: "Batch started", tasks });
});

app.get("/queue-status", (req, res) => {
  const stats = downloadQueue.getStats();
  res.json(stats);
});

app.post("/get-qualities", async (req, res) => {
  const startTime = Date.now();
  let { videoUrl, format } = req.body;

  if (!videoUrl || typeof videoUrl !== "string") {
    return res.status(400).json({ error: "Video URL is required." });
  }

  videoUrl = videoUrl.trim();

  if (!videoUrl) {
    return res.status(400).json({ error: "Video URL is required." });
  }

  if (!/^https?:\/\//i.test(videoUrl)) {
    videoUrl = "https://" + videoUrl;
  }

  videoUrl = normalizeVkUrl(videoUrl);

  if (videoUrl.includes("vimeo.com")) {
    videoUrl = videoUrl.split("?")[0];
  }

  try {
    // Detect YouTube playlist URL without video ID
    if (
      (videoUrl.includes("youtube.com") || videoUrl.includes("youtu.be")) &&
      videoUrl.includes("list=") &&
      !videoUrl.includes("v=")
    ) {
      return res.status(400).json({
        error: "This is a playlist URL. Please use the Batch Download feature.",
      });
    }

    if (videoUrl.includes("threads.net") || videoUrl.includes("threads.com")) {
      const threadsData = await getThreadsVideoData(videoUrl);
      if (threadsData) {
        const qualities = [
          { value: "720p", text: "720p (High Quality)" },
          { value: "480p", text: "480p (Standard Quality)" },
          { value: "360p", text: "360p (Low Quality)" },
        ];

        const result = {
          qualities,
          thumbnail: threadsData.thumbnail,
          title: threadsData.title,
          duration: threadsData.duration,
        };


        logger.info("Threads video qualities fetched successfully", {
          url: videoUrl,
          format,
          qualitiesCount: qualities.length,
          duration: Date.now() - startTime,
        });

        return res.json(result);
      } else {
        return res.status(500).json({
          error: "Failed to extract Threads video information.",
          details: "Could not find video data in the Threads post.",
        });
      }
    }

    // Build yt-dlp args for getting video info (single call with duration)
    let ytDlpInfoArgs = [
      "-m",
      "yt_dlp",
      "--print-json",
      "--no-download",
      "--no-playlist",
      "--no-check-certificate",
      "--ffmpeg-location",
      ffmpeg,
    ];

    // Add YouTube-specific workaround for JS runtime issue
    if (videoUrl.includes("youtube.com") || videoUrl.includes("youtu.be")) {
      ytDlpInfoArgs.push(
        "--extractor-args",
        "youtube:player_client=default,ios"
      );
    }

    // Add Instagram-specific handling for metadata extraction
    if (videoUrl.includes("instagram.com")) {
      ytDlpInfoArgs.push("--extractor-args", "instagram:api=graphql");
      // Add additional headers that might help with Instagram
      ytDlpInfoArgs.push(
        "--add-header",
        "User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
      );
    }

    // Add Vimeo-specific handling
    if (videoUrl.includes("vimeo.com")) {
      ytDlpInfoArgs.push("--extractor-args", "vimeo:player_url=https://player.vimeo.com");
      ytDlpInfoArgs.push("--cookies-from-browser", "chrome");
    }

    // Add impersonation for YouTube
    if (videoUrl.includes("youtube.com") || videoUrl.includes("youtu.be")) {
      ytDlpInfoArgs.push("--impersonate", "Chrome-131");
    }

    ytDlpInfoArgs.push(videoUrl);

    // Use yt-dlp to get video info
    const ytDlp = spawn("py", ytDlpInfoArgs, {
      stdio: ["pipe", "pipe", "pipe"],
    });

    let stdout = "";
    let stderr = "";

    ytDlp.stdout.on("data", (data) => {
      stdout += data.toString();
    });

    ytDlp.stderr.on("data", (data) => {
      stderr += data.toString();
    });

    ytDlp.on("close", (code) => {
      if (code !== 0) {
        logger.error("yt-dlp qualities fetch failed", {
          url: videoUrl,
          format,
          exitCode: code,
          stderr: stderr.substring(0, 500),
        });

        return res.status(500).json({
          error: "Failed to get video info.",
          details: stderr,
        });
      }

      try {
        const videoInfo = JSON.parse(stdout);

        let qualities = [];

        if (format === "mp4") {
          const videoFormats = Array.isArray(videoInfo.formats)
            ? videoInfo.formats
            : [];

          logger.info(
            `Total formats returned by yt-dlp for ${videoUrl}: ${videoFormats.length}`
          );

          qualities = selectVideoQualities(videoFormats);

          if (qualities.length === 0) {
            qualities = [
              buildFallbackQuality(720),
              buildFallbackQuality(1080),
              buildFallbackQuality(1440),
              buildFallbackQuality(2160),
            ];
          }

          logger.info(`Selected formats for ${videoUrl}`, {
            selections: qualities.map((q) => ({
              height: q.height,
              selector: q.value,
              hasAudio: q.hasAudio,
            })),
          });
        } else if (format === "mp3") {
          // For MP3, return standard audio qualities
          qualities.push(
            { value: "128kbps", text: "128 kbps (Standard Quality)" },
            { value: "192kbps", text: "192 kbps (High Quality)" },
            { value: "256kbps", text: "256 kbps (Very High Quality)" },
            { value: "320kbps", text: "320 kbps (Lossless Quality)" }
          );
        }

        // Special handling for Instagram and Threads thumbnails
        let finalThumbnail = videoInfo.thumbnail;
        if (videoUrl.includes("instagram.com") && !finalThumbnail) {
          // Try to extract thumbnail from Instagram URL
          try {
            const instagramMatch = videoUrl.match(/\/(p|reel)\/([^\/]+)/);
            if (instagramMatch) {
              const postId = instagramMatch[2];
              // Try Instagram's oEmbed API for thumbnail
              const oEmbedUrl = `https://www.instagram.com/p/${postId}/embed/`;
              finalThumbnail = `https://www.instagram.com/p/${postId}/media/?size=l`;
            }
          } catch (e) {
            logger.warn("Failed to construct Instagram thumbnail URL", {
              error: e.message,
            });
          }
        }

        const result = {
          qualities,
          thumbnail: finalThumbnail,
          title: videoInfo.title,
          duration: videoInfo.duration,
        };

        // Debug logging for Instagram thumbnail
        if (videoUrl.includes("instagram.com")) {
          logger.info("Instagram video info", {
            url: videoUrl,
            originalThumbnail: videoInfo.thumbnail,
            finalThumbnail: finalThumbnail,
            hasThumbnail: !!finalThumbnail,
            allThumbnails: videoInfo.thumbnails,
            title: videoInfo.title,
          });
        }


        logger.info("Video qualities fetched successfully", {
          url: videoUrl,
          format,
          qualitiesCount: qualities.length,
          duration: Date.now() - startTime,
        });

        res.json(result);
      } catch (parseError) {
        logger.error("JSON parse error in qualities", {
          url: videoUrl,
          error: parseError.message,
        });
        res.status(500).json({ error: "Failed to parse video information." });
      }
    });

    ytDlp.on("error", (error) => {
      logger.error("Spawn error in qualities", {
        url: videoUrl,
        error: error.message,
      });
      res.status(500).json({ error: "Failed to execute yt-dlp." });
    });
  } catch (error) {
    logger.error("Server error in qualities endpoint", {
      url: videoUrl,
      error: error.message,
      stack: error.stack,
      url: videoUrl,
      error: error.message,
      stack: error.stack,
    });
    res
      .status(500)
      .json({ error: "An unexpected error occurred.", details: error.message });
  }
});

app.post("/download", async (req, res) => {
  const downloadStartTime = Date.now();
  logger.info("Download request received", {
    ip: req.ip,
    userAgent: req.get("User-Agent"),
    body: req.body,
    headers: req.headers,
  });

  const { videoUrl, format, quality } = req.body;

  // Support both JSON and form data
  let url = videoUrl || req.body.videoUrl;
  const fmt = format || req.body.format;
  const qual = quality || req.body.quality;
  const formatSelector =
    req.body.formatSelector ||
    req.body.formatId ||
    req.body.selectedFormat ||
    req.body.format_id;
  const qualityLabel = req.body.qualityLabel || qual;
  const requestedHeight =
    parseInt(req.body.selectedHeight || req.body.height, 10) ||
    (typeof qual === "string" && qual.includes("p")
      ? parseInt(qual.replace(/[^\d]/g, ""), 10)
      : null);

  logger.info("Download parameters parsed", {
    url,
    format: fmt,
    quality: qualityLabel || qual,
    formatSelector: formatSelector || null,
  });

  if (!url || !fmt || (!qual && !formatSelector)) {
    return res
      .status(400)
      .json({ error: "Video URL, format, and quality are required." });
  }

  const downloadAccelerator = req.body.downloadAccelerator === "true";
  const startTime = req.body.startTime;
  const endTime = req.body.endTime;

  try {
    // Ensure URL has protocol
    if (!/^https?:\/\//i.test(url)) {
      url = "https://" + url;
    }

    url = normalizeVkUrl(url);

    // Strip query parameters from Vimeo URLs to avoid login redirects
    if (url.includes("vimeo.com")) {
      url = url.split("?")[0];
    }

    // Get video title from yt-dlp
    let videoTitle = "Unknown Title";
    try {
      let titleArgs = [
        "-m",
        "yt_dlp",
        "--print-json",
        "--no-download",
        "--no-playlist",
        "--no-check-certificate",
        "--ffmpeg-location",
        ffmpeg,
      ];

      // Add YouTube-specific workaround for JS runtime issue
      if (url.includes("youtube.com") || url.includes("youtu.be")) {
        titleArgs.push("--extractor-args", "youtube:player_client=default,ios");
      }

      // Add Vimeo-specific handling
      if (url.includes("vimeo.com")) {
        titleArgs.push("--extractor-args", "vimeo:player_url=https://player.vimeo.com");
        titleArgs.push("--cookies-from-browser", "chrome");
      }

      // Add impersonation for YouTube and Vimeo
      if (
        url.includes("youtube.com") ||
        url.includes("youtu.be") ||
        url.includes("vimeo.com")
      ) {
        titleArgs.push("--impersonate", "Chrome-131");
      }

      titleArgs.push(url);

      const titleProcess = spawn("py", titleArgs, {
        stdio: ["pipe", "pipe", "pipe"],
      });
      let titleStdout = "";
      titleProcess.stdout.on("data", (data) => {
        titleStdout += data.toString();
      });
      titleProcess.stderr.on("data", (data) => {
        console.error("Title fetch stderr:", data.toString());
      });
      await new Promise((resolve, reject) => {
        titleProcess.on("close", (code) => {
          if (code === 0) {
            try {
              const info = JSON.parse(titleStdout);
              videoTitle = info.title || "Unknown Title";
            } catch (e) {
              console.error("Parse title error:", e);
            }
          } else {
            console.error("Title fetch failed, code:", code);
          }
          resolve();
        });
        titleProcess.on("error", reject);
      });
    } catch (e) {
      console.error("Title fetch error:", e);
    }

    const safeTitle = videoTitle
      .replace(/[\x00-\x1F\x7F]/g, "")
      .replace(/[<>:"|?*\\]/g, "_")
      .replace(/\s+/g, " ")
      .trim()
      .substring(0, 100);
    const finalTitle = safeTitle || "Video";
    const downloadFilename = `FastPast ‚Äì ${finalTitle}.${fmt}`;
    const contentType = fmt === "mp3" ? "audio/mpeg" : "video/mp4";

    let ytDlpArgs = ["--no-check-certificate", "--no-playlist", "--ffmpeg-location", ffmpeg];

    if (url.includes("youtube.com") || url.includes("youtu.be")) {
      ytDlpArgs.push("--extractor-args", "youtube:player_client=default,ios");
    }

    if (url.includes("instagram.com")) {
      ytDlpArgs.push("--extractor-args", "instagram:api=graphql");
      ytDlpArgs.push(
        "--add-header",
        "User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
      );
    }

    if (url.includes("threads.net") || url.includes("threads.com")) {
      try {
        const threadsData = await getThreadsVideoData(url);
        if (threadsData && threadsData.videoUrl) {
          const curlArgs = [
            "-L",
            "-o",
            "-",
            "-H",
            "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
            "-H",
            "Accept: */*",
            "-H",
            "Accept-Encoding: gzip, deflate",
            "-C",
            "-",
            threadsData.videoUrl,
          ];
          const curlProcess = spawn("curl", curlArgs, {
            stdio: ["ignore", "pipe", "pipe"],
          });
          streamProcessToResponse(res, curlProcess, {
            filename: downloadFilename,
            contentType: "video/mp4",
            onSuccess: () => {
              logger.info("Threads video downloaded successfully via curl", {
                url,
                duration: Date.now() - downloadStartTime,
              });
            },
            onFailure: (reason, stderrText) => {
              logger.error("Threads download failed", {
                url,
                reason,
                stderr: (stderrText || "").substring(0, 1000),
              });
            },
          });
          return;
        }
        throw new Error("Could not extract video data from Threads");
      } catch (e) {
        logger.warn("Threads video download failed", {
          error: e.message,
          url,
        });
        return res.status(500).json({
          error: "Failed to download Threads video",
          details: e.message,
        });
      }
    }

    if (url.includes("youtube.com") || url.includes("youtu.be")) {
      ytDlpArgs.push("--impersonate", "Chrome-131");
    }

    if (url.includes("vimeo.com")) {
      ytDlpArgs.push("--extractor-args", "vimeo:player_url=https://player.vimeo.com");
      ytDlpArgs.push("--cookies-from-browser", "chrome");
    }

    let formatArgs = [];
    if (fmt === "mp4") {
      if (formatSelector) {
        formatArgs = ["-f", formatSelector, "--merge-output-format", "mp4"];
      } else {
        const fallbackHeight = requestedHeight || 720;
        formatArgs = [
          "-f",
          `bestvideo[height<=${fallbackHeight}]+bestaudio/best[height<=${fallbackHeight}]/best`,
          "--merge-output-format",
          "mp4",
        ];
      }
    } else if (fmt === "mp3") {
      const bitrate = qual.replace("kbps", "K");
      formatArgs = [
        "-x",
        "--audio-format",
        "mp3",
        "--audio-quality",
        bitrate,
      ];
    } else {
      return res.status(400).json({ error: "Unsupported format requested." });
    }

    const isYouTube = url.includes("youtube.com") || url.includes("youtu.be");
    if (startTime && endTime && fmt === "mp4" && isYouTube) {
      const startSec = parseTime(startTime);
      const endSec = parseTime(endTime);
      // Use yt-dlp native download sections
      ytDlpArgs.push("--download-sections", `*${startSec}-${endSec}`);
    }

    if (downloadAccelerator) {
      ytDlpArgs.push("--concurrent-fragments", "5");
    }

    const finalYtDlpArgs = [...ytDlpArgs, ...formatArgs, "-o", "-", url];

    console.log("yt-dlp args:", finalYtDlpArgs);

    const baseProcessArgs = ["-m", "yt_dlp", ...finalYtDlpArgs];

    // Spawn unified process
    const ytDlpProcess = spawn("py", baseProcessArgs, {
      stdio: ["ignore", "pipe", "pipe"],
    });

    streamProcessToResponse(res, ytDlpProcess, {
      filename: downloadFilename,
      contentType,
      onSuccess: () => {
        logger.info("Download completed successfully", {
          url,
          format: fmt,
          quality: qualityLabel || qual,
          duration: Date.now() - downloadStartTime,
          clipped: !!(startTime && endTime),
        });
      },
      onFailure: (reason, stderrText) => {
        logger.error("Download failed", {
          url,
          format: fmt,
          quality: qualityLabel || qual,
          reason,
          stderr: (stderrText || "").substring(0, 1000),
        });
      },
    });

  } catch (error) {
    logger.error("Server error in download endpoint", {
      error: error.message,
      stack: error.stack,
      url,
      format: fmt,
      quality: qualityLabel || qual,
    });
    res.status(500).json({ error: "An unexpected error occurred." });
  }
});

server.listen(port, () => {
  logger.info(`Server started successfully`, {
    port,
    environment: process.env.NODE_ENV || "development",
  });
  console.log(`Server is running on http://localhost:${port}`);
});
